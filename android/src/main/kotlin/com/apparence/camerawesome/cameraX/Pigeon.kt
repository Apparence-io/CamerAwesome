// Autogenerated from Pigeon (v4.2.1), do not edit directly.
// See also: https://pub.dev/packages/pigeon

package com.apparence.camerawesome

import android.util.Log
import io.flutter.plugin.common.BasicMessageChannel
import io.flutter.plugin.common.BinaryMessenger
import io.flutter.plugin.common.MessageCodec
import io.flutter.plugin.common.StandardMessageCodec
import java.io.ByteArrayOutputStream
import java.nio.ByteBuffer

/** Generated class from Pigeon. */

enum class PigeonSensorType(val raw: Int) {
  WIDEANGLE(0),
  ULTRAWIDEANGLE(1),
  TELEPHOTO(2),
  TRUEDEPTH(3),
  UNKNOWN(4);

  companion object {
    fun ofRaw(raw: Int): PigeonSensorType? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class PreviewSize(
  val width: Double,
  val height: Double
) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromMap(map: Map<String, Any?>): PreviewSize {
      val width = map["width"] as Double
      val height = map["height"] as Double

      return PreviewSize(width, height)
    }
  }
  fun toMap(): Map<String, Any?> {
    val map = mutableMapOf<String, Any?>()
    map["width"] = width
    map["height"] = height
    return map
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class ExifPreferences(
  val saveGPSLocation: Boolean
) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromMap(map: Map<String, Any?>): ExifPreferences {
      val saveGPSLocation = map["saveGPSLocation"] as Boolean

      return ExifPreferences(saveGPSLocation)
    }
  }
  fun toMap(): Map<String, Any?> {
    val map = mutableMapOf<String, Any?>()
    map["saveGPSLocation"] = saveGPSLocation
    return map
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class VideoOptions(
  val fileType: String,
  val codec: String
) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromMap(map: Map<String, Any?>): VideoOptions {
      val fileType = map["fileType"] as String
      val codec = map["codec"] as String

      return VideoOptions(fileType, codec)
    }
  }
  fun toMap(): Map<String, Any?> {
    val map = mutableMapOf<String, Any?>()
    map["fileType"] = fileType
    map["codec"] = codec
    return map
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class PigeonSensorTypeDevice(
  val sensorType: PigeonSensorType,
  /** A localized device name for display in the user interface. */
  val name: String,
  /** The current exposure ISO value. */
  val iso: Double,
  /** A Boolean value that indicates whether the flash is currently available for use. */
  val flashAvailable: Boolean,
  /** An identifier that uniquely identifies the device. */
  val uid: String
) {
  companion object {
    @Suppress("UNCHECKED_CAST")
    fun fromMap(map: Map<String, Any?>): PigeonSensorTypeDevice {
        val sensorType = PigeonSensorType.ofRaw(map["sensorType"] as Int)!!
        val name = map["name"] as String
        val iso = map["iso"] as Double
        val flashAvailable = map["flashAvailable"] as Boolean
        val uid = map["uid"] as String

        return PigeonSensorTypeDevice(sensorType, name, iso, flashAvailable, uid)
    }
  }
  fun toMap(): Map<String, Any?> {
    val map = mutableMapOf<String, Any?>()
    map["sensorType"] = sensorType.raw
    map["name"] = name
    map["iso"] = iso
    map["flashAvailable"] = flashAvailable
    map["uid"] = uid
    return map
  }
}

@Suppress("UNCHECKED_CAST")
private object CameraInterfaceCodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      128.toByte() -> {
        return (readValue(buffer) as? Map<String, Any?>)?.let {
          ExifPreferences.fromMap(it)
        }
      }
      129.toByte() -> {
        return (readValue(buffer) as? Map<String, Any?>)?.let {
          PigeonSensorTypeDevice.fromMap(it)
        }
      }
      130.toByte() -> {
        return (readValue(buffer) as? Map<String, Any?>)?.let {
          PreviewSize.fromMap(it)
        }
      }
      131.toByte() -> {
        return (readValue(buffer) as? Map<String, Any?>)?.let {
          PreviewSize.fromMap(it)
        }
      }
      132.toByte() -> {
        return (readValue(buffer) as? Map<String, Any?>)?.let {
          VideoOptions.fromMap(it)
        }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }
  override fun writeValue(stream: ByteArrayOutputStream, value: Any?)   {
    when (value) {
      is ExifPreferences -> {
        stream.write(128)
        writeValue(stream, value.toMap())
      }
      is PigeonSensorTypeDevice -> {
        stream.write(129)
        writeValue(stream, value.toMap())
      }
      is PreviewSize -> {
        stream.write(130)
        writeValue(stream, value.toMap())
      }
      is PreviewSize -> {
        stream.write(131)
        writeValue(stream, value.toMap())
      }
      is VideoOptions -> {
        stream.write(132)
        writeValue(stream, value.toMap())
      }
      else -> super.writeValue(stream, value)
    }
  }
}

/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface CameraInterface {
  fun setupCamera(sensor: String, aspectRatio: String, zoom: Double, flashMode: String, captureMode: String, enableImageStream: Boolean, exifPreferences: ExifPreferences, callback: (Boolean) -> Unit)
  fun checkPermissions(): List<String>
  fun requestPermissions(): List<String>
  fun getPreviewTextureId(): Long
  fun takePhoto(path: String, callback: (Boolean) -> Unit)
  fun recordVideo(path: String, options: VideoOptions?)
  fun pauseVideoRecording()
  fun resumeVideoRecording()
  fun receivedImageFromStream()
  fun stopRecordingVideo(callback: (Boolean) -> Unit)
  fun getFrontSensors(): List<PigeonSensorTypeDevice>
  fun getBackSensors(): List<PigeonSensorTypeDevice>
  fun start(): Boolean
  fun stop(): Boolean
  fun setFlashMode(mode: String)
  fun handleAutoFocus()
  fun focusOnPoint(previewSize: PreviewSize, x: Double, y: Double)
  fun setZoom(zoom: Double)
  fun setSensor(sensor: String, deviceId: String?)
  fun setCorrection(brightness: Double)
  fun getMaxZoom(): Double
  fun setCaptureMode(mode: String)
  fun setRecordingAudioMode(enableAudio: Boolean)
  fun availableSizes(): List<PreviewSize>
  fun refresh()
  fun getEffectivPreviewSize(): PreviewSize?
  fun setPhotoSize(size: PreviewSize)
  fun setPreviewSize(size: PreviewSize)
  fun setAspectRatio(aspectRatio: String)
  fun setupImageAnalysisStream(format: String, width: Long, maxFramesPerSecond: Double?)
  fun setExifPreferences(exifPreferences: ExifPreferences)

  companion object {
    /** The codec used by CameraInterface. */
val codec: MessageCodec<Any?> by lazy {
      CameraInterfaceCodec
    }
    /** Sets up an instance of `CameraInterface` to handle messages through the `binaryMessenger`. */
    @Suppress("UNCHECKED_CAST")
    fun setUp(binaryMessenger: BinaryMessenger, api: CameraInterface?) {
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.CameraInterface.setupCamera", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val wrapped = hashMapOf<String, Any?>()
            try {
              val args = message as List<Any?>
              val sensorArg = args[0] as String
              val aspectRatioArg = args[1] as String
              val zoomArg = args[2] as Double
              val flashModeArg = args[3] as String
              val captureModeArg = args[4] as String
              val enableImageStreamArg = args[5] as Boolean
              val exifPreferencesArg = args[6] as ExifPreferences
              api.setupCamera(sensorArg, aspectRatioArg, zoomArg, flashModeArg, captureModeArg, enableImageStreamArg, exifPreferencesArg) {
                reply.reply(wrapResult(it))
              }
            } catch (exception: Error) {
              wrapped["error"] = wrapError(exception)
              reply.reply(wrapped)
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.CameraInterface.checkPermissions", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped = hashMapOf<String, Any?>()
            try {
              wrapped["result"] = api.checkPermissions()
            } catch (exception: Error) {
              wrapped["error"] = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.CameraInterface.requestPermissions", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped = hashMapOf<String, Any?>()
            try {
              wrapped["result"] = api.requestPermissions()
            } catch (exception: Error) {
              wrapped["error"] = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.CameraInterface.getPreviewTextureId", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped = hashMapOf<String, Any?>()
            try {
              wrapped["result"] = api.getPreviewTextureId()
            } catch (exception: Error) {
              wrapped["error"] = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.CameraInterface.takePhoto", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val wrapped = hashMapOf<String, Any?>()
            try {
              val args = message as List<Any?>
              val pathArg = args[0] as String
              api.takePhoto(pathArg) {
                reply.reply(wrapResult(it))
              }
            } catch (exception: Error) {
              wrapped["error"] = wrapError(exception)
              reply.reply(wrapped)
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.CameraInterface.recordVideo", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val wrapped = hashMapOf<String, Any?>()
            try {
              val args = message as List<Any?>
              val pathArg = args[0] as String
              val optionsArg = args[1] as? VideoOptions
              api.recordVideo(pathArg, optionsArg)
              wrapped["result"] = null
            } catch (exception: Error) {
              wrapped["error"] = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.CameraInterface.pauseVideoRecording", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped = hashMapOf<String, Any?>()
            try {
              api.pauseVideoRecording()
              wrapped["result"] = null
            } catch (exception: Error) {
              wrapped["error"] = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.CameraInterface.resumeVideoRecording", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped = hashMapOf<String, Any?>()
            try {
              api.resumeVideoRecording()
              wrapped["result"] = null
            } catch (exception: Error) {
              wrapped["error"] = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.CameraInterface.receivedImageFromStream", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped = hashMapOf<String, Any?>()
            try {
              api.receivedImageFromStream()
              wrapped["result"] = null
            } catch (exception: Error) {
              wrapped["error"] = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.CameraInterface.stopRecordingVideo", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped = hashMapOf<String, Any?>()
            try {
              api.stopRecordingVideo() {
                reply.reply(wrapResult(it))
              }
            } catch (exception: Error) {
              wrapped["error"] = wrapError(exception)
              reply.reply(wrapped)
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.CameraInterface.getFrontSensors", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped = hashMapOf<String, Any?>()
            try {
              wrapped["result"] = api.getFrontSensors()
            } catch (exception: Error) {
              wrapped["error"] = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.CameraInterface.getBackSensors", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped = hashMapOf<String, Any?>()
            try {
              wrapped["result"] = api.getBackSensors()
            } catch (exception: Error) {
              wrapped["error"] = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.CameraInterface.start", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped = hashMapOf<String, Any?>()
            try {
              wrapped["result"] = api.start()
            } catch (exception: Error) {
              wrapped["error"] = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.CameraInterface.stop", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped = hashMapOf<String, Any?>()
            try {
              wrapped["result"] = api.stop()
            } catch (exception: Error) {
              wrapped["error"] = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.CameraInterface.setFlashMode", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val wrapped = hashMapOf<String, Any?>()
            try {
              val args = message as List<Any?>
              val modeArg = args[0] as String
              api.setFlashMode(modeArg)
              wrapped["result"] = null
            } catch (exception: Error) {
              wrapped["error"] = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.CameraInterface.handleAutoFocus", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped = hashMapOf<String, Any?>()
            try {
              api.handleAutoFocus()
              wrapped["result"] = null
            } catch (exception: Error) {
              wrapped["error"] = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.CameraInterface.focusOnPoint", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val wrapped = hashMapOf<String, Any?>()
            try {
              val args = message as List<Any?>
              val previewSizeArg = args[0] as PreviewSize
              val xArg = args[1] as Double
              val yArg = args[2] as Double
              api.focusOnPoint(previewSizeArg, xArg, yArg)
              wrapped["result"] = null
            } catch (exception: Error) {
              wrapped["error"] = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.CameraInterface.setZoom", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val wrapped = hashMapOf<String, Any?>()
            try {
              val args = message as List<Any?>
              val zoomArg = args[0] as Double
              api.setZoom(zoomArg)
              wrapped["result"] = null
            } catch (exception: Error) {
              wrapped["error"] = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.CameraInterface.setSensor", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val wrapped = hashMapOf<String, Any?>()
            try {
              val args = message as List<Any?>
              val sensorArg = args[0] as String
              val deviceIdArg = args[1] as? String
              api.setSensor(sensorArg, deviceIdArg)
              wrapped["result"] = null
            } catch (exception: Error) {
              wrapped["error"] = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.CameraInterface.setCorrection", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val wrapped = hashMapOf<String, Any?>()
            try {
              val args = message as List<Any?>
              val brightnessArg = args[0] as Double
              api.setCorrection(brightnessArg)
              wrapped["result"] = null
            } catch (exception: Error) {
              wrapped["error"] = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.CameraInterface.getMaxZoom", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped = hashMapOf<String, Any?>()
            try {
              wrapped["result"] = api.getMaxZoom()
            } catch (exception: Error) {
              wrapped["error"] = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.CameraInterface.setCaptureMode", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val wrapped = hashMapOf<String, Any?>()
            try {
              val args = message as List<Any?>
              val modeArg = args[0] as String
              api.setCaptureMode(modeArg)
              wrapped["result"] = null
            } catch (exception: Error) {
              wrapped["error"] = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.CameraInterface.setRecordingAudioMode", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val wrapped = hashMapOf<String, Any?>()
            try {
              val args = message as List<Any?>
              val enableAudioArg = args[0] as Boolean
              api.setRecordingAudioMode(enableAudioArg)
              wrapped["result"] = null
            } catch (exception: Error) {
              wrapped["error"] = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.CameraInterface.availableSizes", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped = hashMapOf<String, Any?>()
            try {
              wrapped["result"] = api.availableSizes()
            } catch (exception: Error) {
              wrapped["error"] = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.CameraInterface.refresh", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped = hashMapOf<String, Any?>()
            try {
              api.refresh()
              wrapped["result"] = null
            } catch (exception: Error) {
              wrapped["error"] = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.CameraInterface.getEffectivPreviewSize", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped = hashMapOf<String, Any?>()
            try {
              wrapped["result"] = api.getEffectivPreviewSize()
            } catch (exception: Error) {
              wrapped["error"] = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.CameraInterface.setPhotoSize", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val wrapped = hashMapOf<String, Any?>()
            try {
              val args = message as List<Any?>
              val sizeArg = args[0] as PreviewSize
              api.setPhotoSize(sizeArg)
              wrapped["result"] = null
            } catch (exception: Error) {
              wrapped["error"] = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.CameraInterface.setPreviewSize", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val wrapped = hashMapOf<String, Any?>()
            try {
              val args = message as List<Any?>
              val sizeArg = args[0] as PreviewSize
              api.setPreviewSize(sizeArg)
              wrapped["result"] = null
            } catch (exception: Error) {
              wrapped["error"] = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.CameraInterface.setAspectRatio", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val wrapped = hashMapOf<String, Any?>()
            try {
              val args = message as List<Any?>
              val aspectRatioArg = args[0] as String
              api.setAspectRatio(aspectRatioArg)
              wrapped["result"] = null
            } catch (exception: Error) {
              wrapped["error"] = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.CameraInterface.setupImageAnalysisStream", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val wrapped = hashMapOf<String, Any?>()
            try {
              val args = message as List<Any?>
              val formatArg = args[0] as String
              val widthArg = args[1].let { if (it is Int) it.toLong() else it as Long }
              val maxFramesPerSecondArg = args[2] as? Double
              api.setupImageAnalysisStream(formatArg, widthArg, maxFramesPerSecondArg)
              wrapped["result"] = null
            } catch (exception: Error) {
              wrapped["error"] = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.CameraInterface.setExifPreferences", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val wrapped = hashMapOf<String, Any?>()
            try {
              val args = message as List<Any?>
              val exifPreferencesArg = args[0] as ExifPreferences
              api.setExifPreferences(exifPreferencesArg)
              wrapped["result"] = null
            } catch (exception: Error) {
              wrapped["error"] = wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}

private fun wrapResult(result: Any?): Map<String, Any?> {
  return hashMapOf("result" to result)
}

private fun wrapError(exception: Throwable): Map<String, Any> {
  return hashMapOf<String, Any>(
    "error" to hashMapOf<String, Any>(
      "code" to exception.javaClass.simpleName,
      "message" to exception.toString(),
      "details" to "Cause: " + exception.cause + ", Stacktrace: " + Log.getStackTraceString(exception)
    )
  )
}
